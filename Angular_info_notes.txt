
Angular is Typescript based Framework used to create Single page Application
Angular is opensource
Latest Version 14((2nd June 2022)

Advantage
1)CrossPlatform Support
2)improved speed and Performance
3)Faster Developemtn process
4)support For Unit testing
5)Light Weight Application
6)We Can Use Bootstrap & Material UI 
For Better UI

*)we must have in pc node.js
1)Install Angular CLI
npm install -g @angular/cli

2)uninstalling Angular Cli
npm uninstall -g @angular/cli

3)installing spcific Version of Angular Cli
npm install -g @angular/cli@11

*)Components
Components are Primary Building Block Of Element
1)Basic Component
ng g c Name
2)Component inline style
it doesn't create cs file there are only three files without css file
ng g c Name inline-style
3)Component inline Template
it doesn't create html file there are only three files without html file
ng g c Name --inline-tamplate
4)Stand Alone Componenet
IMP:- We Have to Register first App.module.ts
File Then Run
ng g c name -stanaAlone

*)ng g m Access --routing

This is create model 

*)Routing

1)Routes:- This is Place For Routing Map For Component

2)Router-Link:- This is Directive for Navigate Different Routes

3)Router-Outlet:-This is Place fo Display The Matched Route

*)Child Routing 
*)Group Routing
*)Module Routing 
*)Lazy Loading
Redirect 404 page If route is not Found
Get Routes Value

This is get value of url Of id 
First we pass id in Url 
    {path:"edit/:id",component:EditComponent}
Then we can pass Router Link also
like this
<a routerLink="edit/1">Edit Contact</a>
Then If we can Get Component go to ts File Write This is code

  constructor(private route:ActivatedRoute){}
  ngOnInit(): void {
  const routeid=this.route.snapshot.paramMap.get('id');
  console.log(routeid);
  }

imp:We must have to import ActivetedRoute In Contructor

*)This is Lazy Loading 
{path:"access",loadChildren:()=>import('./access/access.module').then(opt=>opt.AccessModule)},
{path:"login",loadComponent:()=>import('./login/login.component').then(opt=>opt.LoginComponent)}

we have to write this is code only Routing File Directley Lazy Loading is working


This is routing Link is availe

  <a routerLink="access/register">Register</a>
  <a routerLink="login">Login</a>


*)IMP Bindings
*)Interploation(Data-Binding)-{{}}
  headerName="This is Interpolation";
<h2>{{headerName | uppercase}}</h2>

*)Event Binding-()
<input #txt (change)="functionClick(txt.value)">
*)Property Binding[]
<input [disabled]="isdisabled" #txt (change)="functionClick(txt.value)">
  isdisabled=true;

*)Two way Binding:-[()]
<input [(ngModel)]="headerName">
It should be Refelecting to Instant Screen
It is vice versa
*)style Binding:-
 colorname="red"; This is comes in tc file and 
  font='40px';
<h2 [style.color]="colorname" [style.font-size]="font">{{headerName | uppercase}}</h2>

Pipes are Nothing but tranformation of text


*)Directive
Directives are classes that add addtional Behavior to Elements in your
Angular Application
1)Component
2)Attribute Directive
1)Ng Class
2)Ng style
3)Ng Model
3)Structual  Directive
ngif ,ngFor ,ngSwitch

1)Ng Class 
.headclass{
    color:blue;
    font-weight: bold;
    
}
  className='headclass';

<h2 [ngClass]="className">{{headerName | uppercase}}</h2>

2)ngStyle:-ng style accept only Object
  styleValue={"color":"yellow","font-size":"60px"}:-ts File

<h4 [ngStyle]="styleValue">{{headerName | uppercase}}</h4>

1)ngFor
uses 
*)Table Data Binding
*)List Data Binding

*)Implement Authentication
1)Create login And Signup Screen Function
2))Activate /Decative user By Adamin User
3)Customer Curd Operation
4)Implement Role Based Authentication & Dynamic
Menu Generetaion
5)Implement Referesh Token Logic
6)Menu Features in Angular 14
7)Interview Question

1)npm install alertifyjs --save

1)Service
2)Form Type:
1)Templte Driven Form
[if we can handle small validation we can use Template Driven Forms
This is handle Only HTML Files]
2)Reactive Form
[if we can handle complex validation we can use Reactive Driven Forms
This is handle Only ts Files]

1)HTTP Client Module Import 

POST two parameters 
Firts is Links
second Is data
This is we can Store localstorage item in like this is below
 localStorage.setItem('admin',JSON.stringify(this.respdata));

*)This is Most IMP Auth Guard For Seller[prevent the unauthorized access]
1)Make auth Gaurd
2)Apply Gaurd On seller Route
3)Add Data in LocalStorage
4)Add Auth Gaurd on Page Refersh

ng g  guard auth
we have to apply like this 
    {path:"access",loadChildren:()=>import('./access/access.module').then(opt=>opt.AccessModule),
    canActivate:[AuthGuard]
  },
by default it will true

This is Created Interface bacuse of data type
Like This exmple 

*)Logout and seller pages
1)Add Logout Features
2)Diplay Seller Name

just create logout function onces
to clickabled
and 
that function contains localstorage.remove("admin");
this.router.navigate(['']);

1)Template Driven Forms
This  is only validations only html files
 
required FormsModule in app.module.ts File

<form class="example-form" #userSignup="ngForm" (ngSubmit)="signUp(userSignup.value)">
<mat-form-field class="example-full-width">
<mat-label>UserID</mat-label>
<input matInput placeholder="UserId" type="text" name="userid" ngModel required>
</mat-form-field>
<mat-form-field class="example-full-width">
<mat-label>UserName</mat-label>
<input matInput placeholder="username" type="text" name="username" ngModel required>
</mat-form-field>
<mat-form-field class="example-full-width">
<mat-label>Email</mat-label>
<input matInput placeholder="Email" type="text" name="email" ngModel required>
</mat-form-field>       
<mat-form-field class="example-full-width">
<mat-label>Password</mat-label>
<input matInput placeholder="Password" type="password" name="password" ngModel required>
</mat-form-field>
<div>
<button mat-raised-button color="primary" style="margin: 5px;" type="submit">Register</button>
</div>
</form>

All values gets This is tc Files
2)Reactive Forms
This is Forms Handle all Operation in ts Files

   FormGroup({
    userid:new FormControl('',Validators.required),
    username:new FormControl('',Validators.required),
    email:new FormControl('',Validators.compose([Validators.required,Validators.email])),
    password:new FormControl('',Validators.required),
    role:new FormControl('',Validators.required)
  });

signUp(){
    if(this.reactiveform.valid){
      this.service.userSignup(this.reactiveform.value)?.subscribe(item=>{
        this.respdata=item;
        if(this.respdata=item){
          localStorage.setItem('signup',JSON.stringify(this.respdata))
          alertify.success("Registration SuccessFully please contact For Adminstration");
          this.router.navigate(['login']);
        }else{
          alertify.error("Please Try Again ");

        }
    
      });

    }
  

}

This is Html File in code

 <form class="example-form" [formGroup]="reactiveform" (ngSubmit)="signUp()">
            <mat-form-field class="example-full-width">
              <mat-label>UserID</mat-label>
              <input matInput placeholder="UserId" type="text"   formControlName="userid" >
            </mat-form-field>
            <mat-form-field class="example-full-width">
                <mat-label>UserName</mat-label>
                <input matInput placeholder="username" type="text"  formControlName="username">
              </mat-form-field>
              <mat-form-field class="example-full-width">
                <mat-label>Email</mat-label>
                <input matInput placeholder="Email" type="text"    formControlName="email">
              </mat-form-field>
          
            <mat-form-field class="example-full-width">
                <mat-label>Password</mat-label>
                <input matInput placeholder="Password" type="password"   formControlName="password">
              </mat-form-field>

              <mat-form-field class="example-full-width">
                <mat-label>Role</mat-label>
                <input matInput placeholder="Role" type="text"    formControlName="role">
              </mat-form-field>

              <div>
            
              <button mat-raised-button color="primary" style="margin: 5px;" type="submit">Register</button>
              </div>
            
          </form>




*)Implement Authrntication
1)Activate /Deactvate User By admin user
2)Customer Curd Operation
3)implement Role Based Authentication & dynamic
menu Geration
4)Implement Refersh Token Logic
5)new Features in Angular 14
6)Interview Questions

1)If we access path that has no mapping with any component, then to handle 404 Not Found error, 
we use a path (**) that is mapped with any component to show desired message.

{ path: '**', component: PageNotFoundComponent } 

2)It is used to navigate from one component to another component. To use Router in any component, follow the steps.

import { Router } from '@angular/router'; 

3)Using Router navigate() : Call navigate() method of Router and pass path and parameter if any, to navigate from one component to another component. Find the code snippet.

this.router.navigate(['/update-book', id]); 

Here URL /update-book/:id will be the path to navigate. When the navigate() method will be executed, the component mapped with URL /update-book/:id will be displayed.


*****Book Library*********

1)This is Most UseFul Sites
https://www.concretepage.com/
2)we are working on that sites
https://www.concretepage.com/angular-2/angular-2-routing-and-navigation-example


first create Component
1)add-book
2)home
3)manage-book

services
1)Book.service.ts

1. Import RouterModule and Routes : First of all we will import RouterModule and Routes in our component.
2. Create Array of Routes : Create array of Routes in which we map a URL with a component.
const routes: Routes = [
	{ path: 'manage-book', component: ManageBookComponent },
	{ path: 'update-book/:id', component: UpdateBookComponent }, 
	{ path: '', redirectTo: '/manage-book ', pathMatch: 'full' },
	{ path: '**', component: PageNotFoundComponent }
]
b. Configure Parameters : Find the mapping.
{ path: 'update-book/:id', component: UpdateBookComponent } 

In the above path mapping we need to pass a path parameter,
 for example if we access the URL update-book/100 then UpdateBookComponent will be displayed.

c. Redirect to a URL : Find the mapping.
{ path: '', redirectTo: '/manage-book ', pathMatch: 'full' } 

If we access a URL without specifying any component path such as "/" then 
it will be redirected to URL /manage-book path and hence by default ManageBookComponent will be displayed.

d)Handling "Page Not Found" : Find the mapping.
{ path: '**', component: PageNotFoundComponent } 
If we access path that has no mapping with any component, then to handle 404 Not Found error,
we use a path (**) that is mapped with any component to show desired message.

2)Router

1)It is used to navigate from one component to another component. To use Router in any component, follow the steps.
Import Router : Import Router as follows.
import { Router } from '@angular/router'; 


2.)Router Instance: Make Router service available in component using dependency injection with constructor.

constructor(private router: Router) { 
} 

3.)Using Router navigate() : Call navigate() method of Router and pass path and parameter 
if any, to navigate from one component to another component. Find the code snippet.

this.router.navigate(['/update-book', id]); 

3.)ActivatedRoute and Params

ActivatedRoute is an Angular service that contains route specific information such as route parameters, global query params etc. Params is an Angular router API that contains the parameter value. To get the parameter value from Params we need to pass key. To use ActivatedRoute and Params in our component, find the steps.
1. Import ActivatedRoute and Params: Import ActivatedRoute and Params as given below.


import { ActivatedRoute, Params } from '@angular/router'; 

3. Routing with Parameters : Now suppose a URL /update-book/100 is being accessed. To understand the fetching of parameter, find the mapping of component which we configure in module.

{ path: 'update-book/:id', component: UpdateBookComponent } 

URL /update-book/100 will invoke UpdateBookComponent. The path parameter will be accessed by id as given in path mapping with component. We will fetch URL as following.

this.route.params.pipe(
  switchMap((params: Params) => this.bookService.getBook(+params['id']))

).subscribe(book => this.book = book); We need to know following points.

a. switchMap operator allows us to perform an action with the current value of the Observable and map it to 
new Observable. Import switchMap in component as follows.

import { switchMap } from 'rxjs/operators'; switchMap handles an Observable as well as a Promise to retrieve the value they emit.
b. (+) converts string 'id' to a number. In +params['id'], id is the keyword used in URL mapping with component. +params['id'] will return 100 if we use URL /update-book/100 .

c. subscribe is used to detect the id changes to retrieve Book. Book is a class that will be created in our example.

4************ Location*************
Location is a service that is used to interact with browser URL for example navigating back and forward. Location has methods such as go(), forward() and back() etc. To use Location service, find the following points.

1. Import Location : Import Location in component.
import { Location } from '@angular/common'; 

2. Location Instance: Make Location available in component using dependency injection with constructor.

constructor(private location: Location) { 
} 

3. Navigate Back : If we want to go back, then we will call back() method as follows.

this.location.back(); 

2. Add <base href> in index.html

<base> tag in HTML is used to define base URL for relative links. <base> is used within <head> tag. In Angular router it is used to compose navigation URLs. We are adding <base> tag in index.html as follows.

<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Angular Demo</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root>Loading...</app-root>
</body>
</html> 

*******This is used Promises **********

This is type of definig Array in Empty


Book Library 
in tc file if they are using
Promises

if they are selecting
in tc Files

export class BookService {
    getBooks(): Promise<Book[]> {
        return Promise.resolve(BOOKS);
    }
This is getting data to display Like This is Function

**************code Start********************
export class HomeComponent implements OnInit { 
    books: Book[];

    constructor(private bookService: BookService) { }
    getBooks(): void {
        this.bookService.getBooks().then(books => this.books = books);
        
        
    }
    ngOnInit(): void {
       this.getBooks();
    }				
} 

**************code End ********************

*)View Details page to display data when we click to update we  have to pass id in button like This 

This is comes From html Files

 <button (click)="goBack()">Go Back</button>
 <button (click)="updateBook(book.id)">Update</button>

This is comes From tc Files

goBack(): void {
  this.location.back();
}

*)This is type id  send to update_book component  


updateBook(id: number): void {
  this.router.navigate(['/update-book', id]);
}
}


Angular Routing and Navigation Example
By Arvind Rai, March 21, 2021
Angular
This page will walk through Angular routing and navigation example. Using Angular router we can navigate from one view to next while performing our task. Every component can be mapped with a URL and when that URL is accessed by browser or by a link on the page then the corresponding component is displayed. We can pass optional parameter with the URL that will be fetched in component to filter data to display. In our HTML template we can bind router to a link and when link is clicked, it will navigate to appropriate view. We can configure a URL to redirect to next URL. We can also handle "404 Not Found" in Angular routing. Angular routing provides location service using which we can go back and forward through the history of pages using a button. Here on this page first we will discuss the Angular routing API and then we will create a book library for routing and navigation demo. In our example we will navigate from one view to next using menu item as well as button given on the page. Let us start now.
Contents
Technologies Used
Understanding Routing and Navigation API
1. RouterModule and Routes
2. Router
3. ActivatedRoute and Params
4. Location
5. RouterLink and RouterLinkActive
6. RouterOutlet
Routing and Navigation Complete Example
1. Project Structure
2. Add <base href> in index.html
3. Create Routing Module and Application Module
4. Create Menu
5. Create Service
6. Display Contents
7. Add Contents
8. Update and Remove Contents
9. "404 Not Found" Handling
Run Application
References
Download Source Code

Technologies Used
Find the technologies being used in our example.
1. Angular 11.0.3
2. Node.js 12.5.0
3. NPM 6.9.0
Understanding Routing and Navigation API
To work with Angular routing and navigation, first we need to understand their API. Angular routing provides services, directives and operators that manage the routing and navigation in our application. Here we will provide API description and their usability in our routing application. Let us start one by one.
1. RouterModule and Routes
RouterModule is a separate module in Angular that provides required services and directives to use routing and navigation in Angular application. Routes defines and array of roots that map a path to a component. Paths are configured in module to make available it globally. To use RouterModule and Routes in module, find the steps.
1. Import RouterModule and Routes : First of all we will import RouterModule and Routes in our component.
import { RouterModule, Routes } from '@angular/router'; 2. Create Array of Routes : Create array of Routes in which we map a URL with a component.
const routes: Routes = [
	{ path: 'manage-book', component: ManageBookComponent },
	{ path: 'update-book/:id', component: UpdateBookComponent }, 
	{ path: '', redirectTo: '/manage-book ', pathMatch: 'full' },
	{ path: '**', component: PageNotFoundComponent }
] Let us understand the path mapping.
a. Mapping a Route to a Component : Find the mapping.
{ path: 'manage-book', component: ManageBookComponent } In the above mapping when we access URL /manage-book then ManageBookComponent will be displayed.
b. Configure Parameters : Find the mapping.
{ path: 'update-book/:id', component: UpdateBookComponent } In the above path mapping we need to pass a path parameter, for example if we access the URL update-book/100 then UpdateBookComponent will be displayed.
c. Redirect to a URL : Find the mapping.
{ path: '', redirectTo: '/manage-book ', pathMatch: 'full' } If we access a URL without specifying any component path such as "/" then it will be redirected to URL /manage-book path and hence by default ManageBookComponent will be displayed.
d. Handling "Page Not Found" : Find the mapping.
{ path: '**', component: PageNotFoundComponent } If we access path that has no mapping with any component, then to handle 404 Not Found error, we use a path (**) that is mapped with any component to show desired message.


3. Using RouterModule.forRoot() : Now we need to import RouterModule.forRoot(routes) using imports metadata of @NgModule. Here argument routes is our constant that we have defined above as array of Routes to map path with component.

imports: [ RouterModule.forRoot(routes) ] 


2. Router

It is used to navigate from one component to another component. To use Router in any component, follow the steps.
1. Import Router : Import Router as follows.
import { Router } from '@angular/router'; 2. Router Instance: Make Router service available in component using dependency injection with constructor.
constructor(private router: Router) { 
} 3. Using Router navigate() : Call navigate() method of Router and pass path and parameter if any, to navigate from one component to another component. Find the code snippet.
this.router.navigate(['/update-book', id]); Here URL /update-book/:id will be the path to navigate. When the navigate() method will be executed, the component mapped with URL /update-book/:id will be displayed.
3. ActivatedRoute and Params

ActivatedRoute is an Angular service that contains route specific information such as route parameters, global query params etc. Params is an Angular router API that contains the parameter value. To get the parameter value from Params we need to pass key. To use ActivatedRoute and Params in our component, find the steps.
1. Import ActivatedRoute and Params: Import ActivatedRoute and Params as given below.
import { ActivatedRoute, Params } from '@angular/router'; 2. ActivatedRoute Instance: Make ActivatedRoute available in component using dependency injection with constructor.
constructor(private route: ActivatedRoute, private bookService: BookService) {
} In the above code BookService is our service which we will create in our example.
3. Routing with Parameters : Now suppose a URL /update-book/100 is being accessed. To understand the fetching of parameter, find the mapping of component which we configure in module.
{ path: 'update-book/:id', component: UpdateBookComponent } URL /update-book/100 will invoke UpdateBookComponent. The path parameter will be accessed by id as given in path mapping with component. We will fetch URL as following.
this.route.params.pipe(
  switchMap((params: Params) => this.bookService.getBook(+params['id']))
).subscribe(book => this.book = book); We need to know following points.
a. switchMap operator allows us to perform an action with the current value of the Observable and map it to new Observable. Import switchMap in component as follows.
import { switchMap } from 'rxjs/operators'; switchMap handles an Observable as well as a Promise to retrieve the value they emit.
b. (+) converts string 'id' to a number. In +params['id'], id is the keyword used in URL mapping with component. +params['id'] will return 100 if we use URL /update-book/100 .
c. subscribe is used to detect the id changes to retrieve Book. Book is a class that will be created in our example.
4. Location
Location is a service that is used to interact with browser URL for example navigating back and forward. Location has methods such as go(), forward() and back() etc. To use Location service, find the following points.
1. Import Location : Import Location in component.
import { Location } from '@angular/common'; 2. Location Instance: Make Location available in component using dependency injection with constructor.
constructor(private location: Location) { 
} 3. Navigate Back : If we want to go back, then we will call back() method as follows.
this.location.back(); 
5. RouterLink and RouterLinkActive
RouterLink is a directive that is used to bind a route with clickable HTML element. RouterLinkActive is a directive that is used to add or remove CSS classes. When the HTML element with RouterLink binding is clicked then the CSS classes bound with RouterLinkActive will be active. These directives are used are follows.
<a routerLink="/manage-book" routerLinkActive="active-link">Manage Book</a>
<a [routerLink]="['/view-detail', book.id]">View Detail</a> In the first link routerLink is bound with a route and routerLinkActive is bound with a CSS class. When this linked will be clicked then the associated CSS class will be activated. In the second link we are binding only routerLink with a parameter.
6. RouterOutlet
RouterOutlet is a directive that is used as <router-outlet>. The role of <router-outlet> is to mark where the router displays a view. Find the code snippet.
<nav [ngClass] = "'menu'">
   <a routerLink="/home" routerLinkActive="active-link">Home</a> | 
   <a routerLink="/add-book" routerLinkActive="active-link">Add Book</a> | 
   <a routerLink="/manage-book" routerLinkActive="active-link">Manage Book</a>
</nav>   
<router-outlet></router-outlet>	We have created menu items in the above code using RouterOutlet. They will be shown in every view where we navigate using the route binding with routerLink.
Routing and Navigation Complete Example
Now we create a complete example using routing and navigation. We will create a book library. The functionality will be to display book, add books, update and remove books from the library. Find the example step by step.
1. Project Structure
Find the project structure.
angular-demo
|
|--src
|   |
|   |--app 
|   |   |
|   |   |--services
|   |   |   |
|   |   |   |--book.service.ts
|   |   |   |--book.ts
|   |   |   |--mock-books.ts   
|   |   |
|   |   |--home
|   |   |   |
|   |   |   |--home.component.ts
|   |	|   |--home.component.html
|   |	|   |--home.component.css
|   |   |   |--view-detail.component.ts
|   |	|   |--view-detail.component.html
|   |	|   |--view-detail.component.css
|   |   | 
|   |   |--add-book    
|   |   |   |
|   |   |   |--add-book.component.ts
|   |   |   |--add-book.component.html
|   |   |   |--add-book.component.css
|   |   |
|   |   |--manage-book
|   |   |   |
|   |   |   |--manage-book.component.ts
|   |	|   |--manage-book.component.html
|   |	|   |--manage-book.component.css
|   |   |   |--update-book.component.ts
|   |	|   |--update-book.component.html
|   |	|   |--update-book.component.css
|   |   |
|   |   |--app.component.ts
|   |   |--app.component.html
|   |   |--app.component.css
|   |   |--page-not-found.component.ts
|   |   |--app-routing.module.ts 
|   |   |--app.module.ts 
|   | 
|   |--main.ts
|   |--index.html
|   |--styles.css
|
|--node_modules
|--package.json 


Report Ad

2. Add <base href> in index.html
<base> tag in HTML is used to define base URL for relative links. <base> is used within <head> tag. In Angular router it is used to compose navigation URLs. We are adding <base> tag in index.html as follows.
<base href="/"> Find the index.html used in our example.
index.html
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Angular Demo</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root>Loading...</app-root>
</body>
</html> 
3. Create Routing Module and Application Module
We will create module now. To configure routing and navigation we should create a separate module file and that should be imported in main application module file. Creating separate module file will help us to configure link guarding i.e. protecting link navigation in some scenario, for example application using authentication in which some links are allowed only after login. Now find the routing modules.
app-routing.module.ts
import { NgModule }      from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

import { PageNotFoundComponent }  from './page-not-found.component';
import { HomeComponent }  from './home/home.component';
import { ViewDetailComponent }  from './home/view-detail.component';
import { AddBookComponent }  from './add-book/add-book.component';
import { UpdateBookComponent }  from './manage-book/update-book.component';
import { ManageBookComponent }  from './manage-book/manage-book.component';

const routes: Routes = [
        { path: 'home', component: HomeComponent },
	{ path: 'view-detail/:id', component: ViewDetailComponent },		  
	{ path: 'add-book', component: AddBookComponent },
	{ path: 'manage-book', component: ManageBookComponent },
	{ path: 'update-book/:id', component: UpdateBookComponent }, 
	{ path: '', redirectTo: '/home', pathMatch: 'full' },
	{ path: '**', component: PageNotFoundComponent }
];
@NgModule({
  imports: [ RouterModule.forRoot(routes) ],
  exports: [ RouterModule ]
})
export class AppRoutingModule{ } Now find the application modules. Routing module will be imported within application module. Here importing sequence is important and we should import it at the last. app.module.ts
import { NgModule }   from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule }   from '@angular/forms';

import { AppComponent }  from './app.component';
import { PageNotFoundComponent }  from './page-not-found.component';
import { HomeComponent }  from './home/home.component';
import { ViewDetailComponent }  from './home/view-detail.component';
import { AddBookComponent }  from './add-book/add-book.component';
import { UpdateBookComponent }  from './manage-book/update-book.component';
import { ManageBookComponent }  from './manage-book/manage-book.component';
import { AppRoutingModule }  from './app-routing.module';

@NgModule({
  imports: [     
          BrowserModule,
	  FormsModule,
	  AppRoutingModule
  ],
  declarations: [
          AppComponent, 
	  PageNotFoundComponent,
	  HomeComponent,
	  ViewDetailComponent,
	  AddBookComponent,
	  ManageBookComponent,
	  UpdateBookComponent
  ],
  providers: [ ],
  bootstrap: [ AppComponent ]
})
export class AppModule { } We can also use routing module and application module in single module file.
app.module.ts
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule }   from '@angular/forms';
import { NgModule }      from '@angular/core';
import { RouterModule }   from '@angular/router';

import { AppComponent }  from './app.component';
import { PageNotFoundComponent }  from './page-not-found.component';
import { HomeComponent }  from './home/home.component';
import { ViewDetailComponent }  from './home/view-detail.component';
import { AddBookComponent }  from './add-book/add-book.component';
import { UpdateBookComponent }  from './manage-book/update-book.component';
import { ManageBookComponent }  from './manage-book/manage-book.component';

@NgModule({
  imports: [     
           BrowserModule,
	   FormsModule,
	   RouterModule.forRoot([
		  {
			path: 'home',
			component: HomeComponent
		  },
		  {
			path: 'view-detail/:id',
			component: ViewDetailComponent
		  },		  
		  {
			path: 'add-book',
			component: AddBookComponent
		  },
		  {
			path: 'manage-book',
			component: ManageBookComponent
		  },
		  {
			path: 'update-book/:id',
			component: UpdateBookComponent
		  },
		  {
			path: '**',
			component: PageNotFoundComponent 
		  },		  
		  {
		    path: '',
		    redirectTo: '/home',
		    pathMatch: 'full'
		  }
		])
  ],
  declarations: [
        AppComponent, 
	PageNotFoundComponent,
	HomeComponent,
	ViewDetailComponent,
	AddBookComponent,
	ManageBookComponent,
	UpdateBookComponent
  ],
  providers: [
  ],
  bootstrap: [
        AppComponent
  ]
})
export class AppModule { } 
4. Create Menu
Let us start to create links. We will create menu for our application.
app.component.html
<h1>{{title}}</h1>
<nav [ngClass] = "'menu'">
   <a routerLink="/home" routerLinkActive="active-link">Home</a> | 
   <a routerLink="/add-book" routerLinkActive="active-link">Add Book</a> | 
   <a routerLink="/manage-book" routerLinkActive="active-link">Manage Book</a>
</nav>  
<div>	
  <router-outlet></router-outlet>	
</div> <router-outlet> will act as our container where all path bound with routerLink will open.
app.component.ts
import { Component } from '@angular/core';
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html', 
  styleUrls: ['./app.component.css']
})
export class AppComponent { 
  title = "Book Library"
} app.component.css
h1 {
    color: #999;
    margin-bottom: 10;
    font-size: 2em;
}
.menu {
    display: inline-block;
    background-color: #eee;
    border-radius: 4px;

}
.active-link {
    color: #F20B22;
} 

5. Create Service
We are creating a service that will contain methods to fetch, add and remove books.
book.service.ts
import { Injectable } from '@angular/core';
import { Book } from './book';
import { BOOKS } from './mock-books';

@Injectable({
    providedIn: 'root'
})
export class BookService {
    getBooks(): Promise<Book[]> {
        return Promise.resolve(BOOKS);
    }
    addBook(book:Book): void {
		this.getBooks().then(books => {
		     let maxIndex = books.length - 1;
		     let bookWithMaxIndex = books[maxIndex];
		     book.id = bookWithMaxIndex.id + 1;
		     books.push(book);}
		);
    }
    getBook(id: number): Promise<Book> {
        return this.getBooks()
            .then(books => books.find(book => book.id === id));
    }
    deleteBook(id: number): void {
		this.getBooks().then(books => {
		    let book = books.find(ob => ob.id === id);
                    let bookIndex = books.indexOf(book);
                    books.splice(bookIndex, 1);}
		);
    }
} book.ts
export class Book {
   id: number;
   name: string;
   price: string;
   description: string;
   constructor() { 
   }
} mock-books.ts
import { Book } from './book';

export var BOOKS: Book[] = [
  {"id": 1, "name": "Core Java", "price": "25.50", "description": "Core Java Tutorials"},
  {"id": 2, "name": "Angular", "price": "15.20", "description": "Learn Angular"},
  {"id": 3, "name": "Hibernate", "price": "13.50", "description": "Hibernate Examples"},
  {"id": 4, "name": "TypeScript", "price": "26.40", "description": "TypeScript Tutorials"}
]; 
6. Display Contents
Here we will create component that will display the details of books.
home.component.ts
import { Component, OnInit } from '@angular/core';

import { Book } from '../services/book';
import { BookService } from '../services/book.service';

@Component({
    selector: 'home-app',
    templateUrl: './home.component.html',
    styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit { 
    books: Book[];
    constructor(private bookService: BookService) { }
    getBooks(): void {
        this.bookService.getBooks().then(books => this.books = books);
    }
    ngOnInit(): void {
        this.getBooks();
    }				
} home.component.html
<h2>Book Details</h2>
<ul [ngClass] = "'home'">
  <li *ngFor="let book of books" >
        Id: {{book.id}}, Name: {{book.name}} | 
	<a [routerLink]="['/view-detail', book.id]">View Detail</a>
  </li>
</ul> home.component.css
h2 {
  font-size: 1.5em;
  margin-top: 10;
}
.home {
  padding: 0;	
}
.home  a{
  margin-top: 10px;
  display: inline-block;
  background-color: #eee;
  text-decoration: none;
} Find the print screen.

Angular Routing and Navigation Example

When we click on "View Detail", then view-detail/:id route is called where id will be book id. To handle the view detail we have the following component.

view-detail.component.ts

import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router, Params } from '@angular/router';
import { Location } from '@angular/common';
import { switchMap } from 'rxjs/operators';

import { Book } from '../services/book';
import { BookService } from '../services/book.service';

@Component({
    selector: 'view-detail-app',
    templateUrl: './view-detail.component.html',
    styleUrls: ['./view-detail.component.css']
})
export class ViewDetailComponent implements OnInit {
    book: Book = new Book();
    constructor(private route: ActivatedRoute,
        private router: Router,
        private bookService: BookService,
        private location: Location) { }
    ngOnInit(): void {
        this.route.params.pipe(
            switchMap((params: Params) => this.bookService.getBook(+params['id']))
        ).subscribe(book => this.book = book);
    }
    goBack(): void {
        this.location.back();
    }
    updateBook(id: number): void {
        this.router.navigate(['/update-book', id]);
    }
}view-detail.component.html
<h2>View Detail</h2>
<ul [ngClass] = "'view-detail'">
  <li>
    Id: {{book.id}}
  </li>
  <li>
    Name: {{book.name}}
  </li>
  <li>
    Price: {{book.price}}
  </li>
  <li>
    Description: {{book.description}}
  </li>  
</ul>
<div>
 <button (click)="goBack()">Go Back</button>
 <button (click)="updateBook(book.id)">Update</button>
</div>
<div>
 <a [routerLink]="['/buy-book']">Buy Book</a>
</div>

7. Add Contents
Find the component that will add books in library.

add-book.component.ts

**************code Start********************
export class AddbookComponent implements OnInit {
  books: Book[];
    book: Book = new Book();
    constructor(private router: Router,
	        private bookService: BookService) { }
    getBooks(): void {
        this.bookService.getBooks().then(books => this.books = books);
    }
    ngOnInit(): void {
        this.getBooks();
    }
    addBook(): void {
	this.bookService.addBook(this.book);
        this.router.navigate(['/home']);
    }	
}

**************code End ********************
*)This is html Files
**************code Start********************
*)IMP
We are using two-way binding using ngModel.

<h2>Add Book</h2>
<div>
 <div>
    <label>Name: </label>
    <input [(ngModel)]="book.name" />
 </div>	
 <div>
    <label>Price: </label>
    <input [(ngModel)]="book.price" />
 </div>	
 <div>
    <label>Short Description: </label>
    <input [(ngModel)]="book.description" />
 </div>	 
 <div>
    <button (click)="addBook()">Add</button>
 </div>
</div>  	
}

**************code End ********************

8. Update and Remove Contents

Find the component to manage the books. The following component will display books details and links to update and remove the books.
manage-book.component.ts

**************code Start********************
ts File manage-book.ts

export class ManageBookComponent implements OnInit { 
    books: Book[];
    book: Book = new Book();
    constructor(private router: Router,
	        private bookService: BookService) { }
    getBooks(): void {
        this.bookService.getBooks().then(books => this.books = books);
    }
    ngOnInit(): void {
        this.getBooks();
    }
    updateBook(id:number): void {
	this.router.navigate(['/update-book', id]);
    }
    deleteBook(id:number): void {
	this.bookService.deleteBook(id);
    }
} 
*******************This is html Files***********
<h2>Manage Book</h2>
<ul [ngClass] = "'manage-book'">
  <li *ngFor="let book of books" >
          Id: {{book.id}}, Name = {{book.name}}
	  <button (click)="updateBook(book.id)">Update</button>
	  <button (click)="deleteBook(book.id)">Remove</button>
  </li>
</ul>
**************code End********************
12/18/2022
Life Cycle Hooks
1)Angular Life cycle Hooks are Methods
2)it's Applicable for Both Component Directive
3)it invokes when directives or components
creates changes and destroys them

Events
1)ngOnchanges
2)ngOninit
3)ngDoCheck
4)ngAfterContentInt
5)ngAfterContentChecked
6)ngAfterViewInt
7)ngAfterViewChecked
8)ngOnDestory


2)Process

1)When Angular Application starts
it first create and  render root component.then it's render the
child component.

2)once component is loaded it's start the process of rendering view.
For doing this one it will check input property
evaluate the data binding

*)Constructor 
1)constructor is javascript featurs it's invoded once the class is created

2)when constructor  is called non of the component
input's are not avaible to use.

3)once angular initiate the class kick start change detection cycle of component.

*)Basic Events

1)NgonChanges:-if any input property changes

2)ngOnint
1)it executes one time
2)perfect place for implement initiate logic
3)none of child component are not loaded


3)ngDocheck
it invokes during every change detection cycle

4)ngOnDestory
invoked when then component is destory 


*)Component Specific
4)ngAfterComtentInit:-it is invoked immediately after 
angular has completed initialization  of all of the component's 
content.

it is invoked only once when component is instantiated

5)ngAfterContentChecked:-
it is called every changes detection event after completeing
the component content projections


6)ngAfterViewInt:-it is invoked immediately after angular has completed
initizlization of a component's view

it is invoked only once when the view is instantiated

7)ngAfterViewChecked:-it's raised every changes detection

*********************alertifyjs.save pacakage how do I install**********************
1)npm install alertifyjs --save

to import style.css Files Golbally 
2)@import '../node_modules/alertifyjs//build/css/alertify.min.css';
@import '../node_modules/alertifyjs//build/css/themes/bootstrap.min.css';
@import '../node_modules/alertifyjs//build/css/themes/default.min.css';

3)import * as alertify from 'alertifyjs';
4)"typeRoots":["node_modules/@type","src/alertifytype.d.ts"],

5)alertifytype.d.ts :-declare module 'alertifyjs';

6)"typeRoots": ["node_modules/@types","src/alertifytype.d.ts"],[ this is code added to in tsconig. file]

*)if you are using Forms or any you have to import 
card or any UI material UI 
concept 



<!---- <div>
    <label>Name: </label>
    <input [(ngModel)]="book.name" />
 </div>	
 <div>
    <label>Price: </label>
    <input [(ngModel)]="book.price" />
 </div>	
 <div>
    <label>Short Description: </label>
    <input [(ngModel)]="book.description" />
 </div>	 
 <div>
    <button (click)="addBook()">Add</button>
 </div>-->

1)Angular Route Guards: CanActivate and CanActivateChild Example

Route Guards
Guarding routes means whether we can visit the route or not. For example in login authentication based application, a user has to login first to enter into the application. If there is no route guard then anyone can access any link but using route guard we restrict the access of links. To achieve route guards, Angular provides following interfaces that are contained in @angular/router package.
1. CanActivate
2. CanActivateChild
3. CanDeactivate
4. Resolve
5. CanLoad

In this article we will discuss CanActivate and CanActivateChild. The CanActivate decides whether we can navigate to a route or not. It is used to redirect to login page to require authentication. CanActivateChild decides whether we can navigate to child routes or not. It is used to decide link access on the basis of authorization. It is possible that those links accessible to ADMIN role, will be not be allowed to USER role. Let us understand how to use CanActivate and CanActivateChild route guards.

A. Using CanActivate

1. CanActivate is an Angular interface. It is used to force user to login into application before navigating to the route. Find the declaration of CanActivate interface from Angular doc.

interface CanActivate { 
  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean>|Promise<boolean>|boolean
} 


CanActivate interface has a method named as canActivate() which has following arguments.

1)ActivatedRouteSnapshot: Contains the information about a route associated with component loaded in outlet in particular time. It can traverse router state tree.

2)RouterStateSnapshot: It is a tree of activated route snapshots. It has url property that gives the URL from which this snapshot was created.

canActivate() returns boolean value or Observable or Promise of boolean value.
2. We need to create a service implementing CanActivate interface and override canActivate() method.

@Injectable()
export class AuthGuardService implements CanActivate  {
  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    return true;
  }
} 

3. Use canActivate property of Route interface to guard the route and assign service class implementing CanActivate interface, for example AuthGuardService. Now find the canActivate property used in route declarations.
{
   path: 'home',
   component: DashboardLayoutComponent,
   canActivate: [ AuthGuardService ]
} If canActivate() method from AuthGuardService returns true only when route can be navigated. In case of false value, navigation can be redirected to login page.

B. Using CanActivateChild

1. CanActivateChild is an Angular interface to guard child routes. Suppose a user has been authenticated but not authorized to visit the child routes, so child routes can be guarded using CanActivateChild. Find its declaration from the Angular doc.
interface CanActivateChild { 
  canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable|Promise|boolean
} 
Method signature of canActivateChild() is the same as canActivate() .
2. We need to create a service implementing CanActivateChild and override canActivateChild() method.
@Injectable()
export class AuthGuardService implements CanActivate, CanActivateChild {
  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    return true;

  }
  canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    return true;
  }  
} 3. Use canActivateChild property of Route interface to guard the route and assign service class implementing CanActivateChild interface, for example AuthGuardService. Now find the canActivateChild property used in route declarations.
path: 'list',
component: ArticleListComponent,
canActivateChild: [ AuthGuardService ],			
children: [
  {
     path: ':id',
     component: ArticleEditComponent
  }
] In the above route declarations child routes can only be accessed if canActivateChild() method returns true.
********End*************************

27/12/2022
1)Observable Subscribe-Promise -pipes
2)Real time data update

Observable:-
a sequence of data which is emitted asynchronously 
over period of time

IMP:-
[
*)Create Observable (it can emit multiple values)
1)Rxjs Operator "of"
2)=>convert any array into observable
3)new observable 
3)alwayas use "$" sign for variable

*)Without subscribe method Observable is nothing

bservable is one of the rxjs feature for hold and transmit the data to different receiver. 
For getting data from observable your to subscribe or topromise it

*************************End**************************************************
29/12/2022


*)CanDeactivate Interface

This page will walk through Angular CanDeactivate guard example. The CanDeactivate is an interface that is implemented by our class to create a route guard to decide if a route can be deactivated. The guard can be added to any component route using canDeactivate attribute of Angular Route interface. Any route which needs to use CanDeactivate guard, has to define canDeactivate method and that will be called by our route guard service. We can also create component-specific CanDeactivate guard. The route guard is created as Angular service and Router can inject it during the navigation process. While deactivating route using CanDeactivate guard, we need to open a confirmation dialog box to take user confirmation if user wants to stay on the page or leave the page.
The CanDeactivate guard can be used in the scenario where a user is changing form data and before saving, user tries to navigate away. In this scenario we can use CanDeactivate guard to deactivate the route and open a Dialog Box to take user confirmation.
Here on this page we will create CanDeactivate guard that can be used with any component and we will also create component specific CanDeactivate guard. Now let us discuss complete example step-by-step.


CanDeactivate interface is a route guard to decide if a route can deactivated. Find the structure of CanDeactivate interface from Angular doc.

interface CanDeactivate<T> { 
    canDeactivate(component: T, 
      currentRoute: ActivatedRouteSnapshot,
      currentState: RouterStateSnapshot,
      nextState?: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean
} 

CanDeactivate interface has a method canDeactivate that accepts arguments as given below.

a. Component for which route is to be deactivated.
b. ActivatedRouteSnapshot
c. RouterStateSnapshot
d. RouterStateSnapshot


canDeactivate method will return Observable<boolean> or Promise<boolean> or boolean .

To use CanDeactivate in our application, we need to create a guard. This will be a service decorated with @Injectable() and will define canDeactivate() method. If a component needs CanDeactivate route guard then that component has also to create a method named as canDeactivate() .
Find the sample output of our application for CanDeactivate guard.

****************End********************************************
30-12-2022

This page will walk through Angular module loading example. A module can be loaded eagerly, lazily and preloaded. Eager loading is loading modules before application starts. Lazy loading is loading modules on demand. Preloading is loading modules in background just after application starts. In lazy loading and preloading, modules are loaded asynchronously.
The application module i.e. AppModule is loaded eagerly before application starts. But the feature modules can be loaded either eagerly or lazily or preloaded.
Eager loading: To load a feature module eagerly, we need to import it into application module using imports metadata of @NgModule decorator. Eager loading is useful in small size applications. In eager loading, all the feature modules will be loaded before the application starts. Hence the subsequent request to the application will be faster.
Lazy loading: To load a feature module lazily, we need to load it using loadChildren property in route configuration and that feature module must not be imported in application module. Lazy loading is useful when the application size is growing. In lazy loading, feature module will be loaded on demand and hence application start will be faster.
Preloading: To preload a feature module, we need to load it using loadChildren property and configure preloadingStrategy property in RouterModule.forRoot. That feature module must not be imported in application module. When we assign Angular PreloadAllModules strategy to preloadingStrategy property, then all feature modules configured with loadChildren, are preloaded. To preload selective modules, we need to use custom preloading strategy. We should preload only those features which will be visited by users just after application start and rest feature modules can be loaded lazily. In this way we can improve the performance of our bigger size application.

In our demo application, we have two feature modules CountryModule and PersonModule. We will create three demo applications. In the first application, we will load these feature modules eagerly. In the second application, we will load them lazily and in the third application we will preload them.

1)Eager Loading

1. In eager loading module, feature modules are loaded before application start on the first hit. To load a feature module eagerly, we need to import that module in application module i.e. AppModule using imports metadata of @NgModule decorator.
2. When a module is loaded, it loads all the imported modules, configured components, services, custom pipes etc.
3. Modules are loaded in the order they are configured in imports metadata.
4. Eager loading is good for small applications because at the first hit of the application all the modules are loaded and all the required dependencies are resolved. Now the subsequent access to the application will be faster.

Now find the example. In the example we have two feature modules and we will load them eagerly.
Module and routing module for feature 1:

This is IMP[commands]
 
ng g module country --routing
 it is creating module in routing 


****************************************************END*******************
5-01-2023

[ IMP

In Angular, a reactive form is a FormGroup that is made up of FormControls. Y
The FormBuilder is the class that is used to create both FormGroups and FormControls
**************IMP1********************
Its almost the same. I always try to use form builder because 
its more flexible specially when we are talking about dynamic form creation. 
If you have dynamic form creation you just path it an object and it will return you FormGroup.
**************IMP2********************
Using FormBuilder over FormGroup helps to improve application performance.
**************IMP3********************
FormGroup new = new object created - has to be deleted manually (NOT GOOD FOR APPLICATION MEMORY PERFORMANCE)

this.form1 = new FormGroup({})

FormBuilder(helper class)


creating FormBuilder object (Removing 'new' keyword)
it needs to be injected in constructor
constructor(private _fb:FormBuilder) { }

this.form1 = this._fb.group({})
	
]
**************IMPEND ********************
*)[Creating FormGroup inside FormGroup in Angular][IMP]

On this page we will learn to create FormGroup inside FormArray in Angular application. The FormGroup tracks the value and validity state of a group of FormControl instances. The FormArray tracks the value and validity state of an array of FormControl, FormGroup or FormArray instances. Inside a FormArray, we can create FormControl, FormGroup or FormArray.
Here in our example, we will create FormGroup inside FormArray.
Find the TypeScript code.
*****************************END***************************************
6-01-2023
***************************Start****************************************
9/01/2023

*)Creating-FormGroup-inside-FormArray-in-Angular
This is Html Files



<h3>Create New Team</h3>

<div class="team">
  <form [formGroup]="teamForm" (ngSubmit)="onFormSubmit()">
    <p><b>Team Name : </b> <input formControlName="teamName">
      <br /><label *ngIf="teamName?.dirty && teamName?.hasError('required')" class="error">
        Team name required. </label>
    </p>
    <b> Employees in Team :</b><br><br>
    <div formArrayName="employees">
      <div *ngFor="let emp of employees.controls; let i = index" [formGroupName]="i" class="employee">
        <p> <b>Employee {{i + 1}} : </b> </p>
        <p> Name: <input formControlName="empName"> 
          <label *ngIf="emp.get('empName')?.hasError('required')" class="error">
            Employee name required. </label>
        </p>
        <p> Age: <input formControlName="age">
          <label *ngIf="emp.get('age')?.hasError('min')" class="error">
           Minimum Age is 18. </label>
          <label *ngIf="emp.get('age')?.hasError('required')" class="error">
            Age required. </label>        
        </p>
        <p> City: <input formControlName="city">
          <label *ngIf="emp.get('city')?.hasError('required')" class="error">
            City required. </label>
        </p>
        <p> <button type="button" (click)="deleteEmployeeControl(i)">Delete</button> </p>
      </div>
    </div>
    <button type="button" (click)="addEmployeeControl()">Add Employee</button><br />
    <button type="button" (click)="resetEmployees()">Reset Employees</button><br />
    <button type="button" (click)="clearEmployeeControls()">clear Employees</button><br /><br />
    <button>SUBMIT</button>
  </form>
</div>

2)[This is tc Files]

import { Component, OnInit } from '@angular/core';
import { FormControl, FormArray, Validators, FormBuilder } from '@angular/forms';
import { TeamManagementService } from './team-management.service';

@Component({
	selector: 'app-team',
	templateUrl: './team-management.component.html'
})
export class TeamManagementComponent implements OnInit {
	constructor(
		private formBuilder: FormBuilder,
		private teamMngService: TeamManagementService) {
	}
	ngOnInit() {
	}
	teamForm = this.formBuilder.group({
		teamName: ['', Validators.required],
		employees: this.formBuilder.array([]) //  Employee name is array name pf html files This is Arrya name of html files in in 
// div name  go and seee
	});
	get teamName() {
		return this.teamForm.get('teamName') as FormControl;
	}
	get employees() {
		return this.teamForm.get('employees') as FormArray;
	}
	addEmployeeControl() {
		const empGroup = this.formBuilder.group({
			empName: ['', Validators.required],
			age: ['', [Validators.required, Validators.min(18)]],
			city: ['', Validators.required]
		});
		this.employees.push(empGroup);
	}
	deleteEmployeeControl(index: number) {
		this.employees.removeAt(index);
	}
	resetEmployees() {
		this.employees.reset();
	}
	clearEmployeeControls() {
		this.employees.clear();
	}
	onFormSubmit() {
		if (this.teamForm.valid) {
		  this.teamMngService.saveTeam(this.teamForm.value);
	       this.teamForm.reset();
		}
	}
}
***************************END****************************************
10/1/2023

This page will walk through Angular FormArray example. 
Angular FormArray tracks the value and validity state of an array of FormControl, FormGroup or FormArray instances.
Let us create an array of FormControl using FormArray.

Find the constructor of FormArray class used to create its new instance.

1. controls : Array of child controls i.e. array of FormControl, FormGroup or FormArray instances.
2. validatorOrOpts : This is optional. This is the second argument in which we pass a synchronous validator or its array.
3. asyncValidator : This is optional. This is the third argument in which we pass an async validator or its array.

Find some of the methods of FormArray class.

at(): Returns the AbstractControl instance for the given index. 
The AbstractControl is the base class for FormControl, FormGroup and FormArray classes.
push(): Inserts the new AbstractControl at the end of array.
insert(): Inserts a new AbstractControl at the given index in the array.
removeAt(): Removes the control at the given index in the array.
setControl(): Sets a new control replacing the old one.
setValue(): Sets the value to every control of this FormArray.
patchValue(): Patches the value to available controls starting from index 0.
reset(): Resets the values.
getRawValue(): The aggregate value of the array.
clear(): Removes all controls in this FormArray.

*)Using FormBuilder.array()

The FormBuilder.array() constructs a new FormArray. The FormBuilder has following methods.
group() : Construct a new FormGroup instance.
control() : Construct a new FormControl.
array() : Constructs a new FormArray.

Find the FormBuilder.array() method signature.

controlsConfig: An array of child controls or control configs.
validatorOrOpts: This is optional. A synchronous validator function, or an array of such functions.
asyncValidator: This is optional. A single async validator or array of async validator functions.

  <button [disabled]="teamForm.invalid">SUBMIT</button>

tc Files

teamForm = this.formBuilder.group({
		teamName: ['', Validators.required],
		employees: this.formBuilder.array([
			new FormControl()
		], [Validators.required, Validators.maxLength(5)])
	});
	get teamName() {
		return this.teamForm.get('teamName') as FormControl;
	}	
	get employees() {
		return this.teamForm.get('employees') as FormArray;
	}
	addEmployeeControl() {
		this.employees.push(new FormControl());
	}
	deleteEmployeeControl(index: number) {
		this.employees.removeAt(index);
	}
	insertEmployeeControl() {
		this.employees.insert(1, new FormControl());
	}
	setEmployeeControl() {
		this.employees.setControl(2, new FormControl('Shiv'));
	}
	setEmployeeValue() {
		this.clearEmployeeControls();
		this.addEmployeeControl();
		this.addEmployeeControl();
		this.addEmployeeControl();
		this.employees.setValue(['Mahesh', 'Vishal', 'Krishn']);
	}
	patchEmployeeValue() {
		this.employees.patchValue(['Mahesh', 'Vishal', 'Krishn']);
	}
	resetEmployees() {
		this.employees.reset();
	}
	clearEmployeeControls() {
		this.employees.clear();
	}
	onFormSubmit() {
		const emp = this.employees.at(0);
		console.log(emp.value);
	    const rawVal = this.employees.getRawValue();
		console.log(rawVal);		
		//this.teamMngService.saveTeam(this.teamForm.value);
		this.teamForm.reset();
	}
}




		

























